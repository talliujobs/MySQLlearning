# MySQL优化

## 索引
**建立索引的四个原则**
1. 较频繁的作为查询条件的字段应该创建索引
2. 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
3. 更新非常频繁的字段不适合创建索引
4. 不会出现在WHERE子句中的字段不创建索引

**MySQL 中索引的限制**
1. MyISAM 存储引擎索引键长度总和不能超过1000 字节
2. BLOB 和TEXT 类型的列只能创建前缀索引
3. MySQL 目前不支持函数索引
4. 使用不等于（!= 或者<>）的时候MySQL 无法使用索引
5. 过滤字段使用了函数运算后（如abs(column)），MySQL 无法使用索引
6. Join 语句中Join 条件字段类型不一致的时候MySQL 无法使用索引
7. 使用LIKE 操作的时候如果条件以通配符开始（ '%abc...'）MySQL 无法使用索引
8. 使用非等值查询的时候MySQL 无法使用Hash 索引

自建索引，对全文本搜索有奇效，可用于解决like查询的扫表问题


## SQL语句
## 主从复制
## 分库分表
### 垂直分表
将表按照功能模块、关系密切程度划分出来，部署到不同的数据表上。
* 比如user表中和user_details表。
* 比如博客表中的title和content表
* 大字段垂直切分

垂直切分的优点
数据库的拆分简单明了，拆分规则明
* 应用程序模块清晰明确，整合容易
* 数据维护方便易行，容易定位

垂直切分的缺点
◆部分表关联无法在数据库级别完成，需要在程序中完成
◆对于访问极其频繁且数据量超大的表仍然存在性能瓶颈，不一定能满足要求
◆事务处理相对更为复杂
◆切分达到一定程度之后，扩展性会遇到限制
◆过度切分可能会带来系统过渡复杂而难以维护


### 水平分表
依据的条件可以是时间、地域、功能等比较清晰的条件
* 比如财务报表、薪资发放就可以用时间进行水平分割；
* 比如商品库存就可以用地域进行分割
* 比如用户表的普通用户、商户就可以用功能来进行划分


**水平通用分表策略**
1. 以uuid作为全局唯一标识，为每一个新生成的用户生成uuid
2. 将uuid进行md5加密，生成16进制随机字符串，取随机字符串前两位进行10进制转换，对分表数量的取余，获取插入的表后缀名。
3. 比如建立8张表，对8取余，则会生成user_0...user_7，每个用户会随机插入这8张表中

**分表后，如何统计数据？**
所有统计数据都是根据业务需求而来的，原始数据存在的情况，我们可以进行自建索引，实现具体的业务需求。比如根据添加时间自建索引

** 分表后查询效率的问题？** 
* 根据自建索引表，获取uuid，再根据uuid获取数据每一行的数据。只不过多了一个10次的for循环而已，而php的10for循环可以说是微秒级的。
* 结果集存储的是指针
* mysql_fetch_row()读取磁盘文件
**水平切分的优点**
* 表关联基本能够在数据库端全部完成
* 不会存在某些超大型数据量和高负载的表遇到瓶颈的问题
* 应用程序端整体架构改动相对较少
* 事务处理相对简单
* 只要切分规则能够定义好，基本上较难遇到扩展性限制

**水平切分的缺点**
* 切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则
* 后期数据的维护难度有所增加，人为手工定位数据更困难
* 应用系统各模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难

### 垂直与水平联合切分的使用
**联合切分的优点**
* 可以充分利用垂直切分和水平切分各自的优势而避免各自的缺陷
* 让系统扩展性得到最大化提升
**联合切分的缺点**
* 数据库系统架构比较复杂，维护难度更大；
* 应用程序架构也相对更复杂；


## 锁表
MySQL 各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定
### 行级锁定（row-level）
* 能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能
* 由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。
 

### 表级锁定（table-level）
* 实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。
* 最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣
### 页级锁定（page-level）
MySQL 中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见

* 锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间
* 使用表级锁定的主要是MyISAM，Memory，CSV 等一些非事务性存储引擎，而使用行级锁定的主要是Innodb 存储引擎和NDB Cluster 存储引擎，页级锁定主要是BerkeleyDB 存储引擎的锁定方式。

### MyISAM 表锁优化
1. 缩短锁定时间,让我们的Query 执行时间尽可能的短。
	* 尽量减少大的复杂Query，将复杂Query 分拆成几个小的Query 分步进行；
	* 尽可能的建立足够高效的索引，让数据检索更迅速；
	* 尽量让MyISAM 存储引擎的表只存放必要的信息，控制字段类型；
	
2. MyISAM 的存储引擎有Concurrent Insert（并发插入）的特性。制是否打开Concurrent Insert 功能的参数选项：concurrent_insert，可以设置为0，1 或者2。三个值的具体说明如下：
	* concurrent_insert=2，无论MyISAM 存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都允许在数据文件尾部进行Concurrent Insert;
	* concurrent_insert=1，当MyISAM 存储引擎表数据文件中间不存在空闲空间的时候，可以从文件尾部进行Concurrent Insert;
	* concurrent_insert=0，无论MyISAM 存储引擎的表数据文件的中间部分是否存在因为删除数据而留下的空闲空间，都不允许Concurrent Insert。

如果我们的系统是一个以读为主，而且要优先保证查询性能的话，我们可以通过设置系统参数选项low_priority_updates=1，将写的优先级设置为比读的优先级低，即可让告诉MySQL 尽量先处理读请求。 可以利用这个特性，将concurrent_insert 参数设置为1，甚至如果数据被删除的可能性很小的时候，如果对暂时性的浪费少量空间并不是特别的在乎的话，将concurrent_insert 参数设置为2 都可以尝试。当然，数据文件中间留有空余空间，在浪费空间的时候，还会造成在查询的时候需要读取更多的数据，所以如果删除量不是很小的话，还是建议将concurrent_insert 设置为1 更为合适。

### Innodb 行锁优化
虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM 的表级锁定的。当系统并发量较高的时候，Innodb 的整体性能和MyISAM 相比就会有比较明显的优势了

* 合理利用Innodb 的行级锁定
	* 尽可能让所有的数据检索都通过索引来完成，从而避免Innodb 因为无法通过索引键加锁而升级为表级锁定；
	* 合理设计索引，让Innodb 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query 的执行；
	* 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录；
	* 尽量控制事务的大小，减少锁定的资源量和锁定时间长度；
	* 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减MySQL 因为实现事务隔离级别所带来的附加成本；

* 减少死锁产生概率建议
	* 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；
	* 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
	* 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率
* 系统锁定争用情况查询


## 数据类型
## 缓存

