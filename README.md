# MySQL优化

## 索引
**建立索引的四个原则**
1. 较频繁的作为查询条件的字段应该创建索引
2. 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
3. 更新非常频繁的字段不适合创建索引
4. 不会出现在WHERE子句中的字段不创建索引

**MySQL 中索引的限制**
1. MyISAM 存储引擎索引键长度总和不能超过1000 字节
2. BLOB 和TEXT 类型的列只能创建前缀索引
3. MySQL 目前不支持函数索引
4. 使用不等于（!= 或者<>）的时候MySQL 无法使用索引
5. 过滤字段使用了函数运算后（如abs(column)），MySQL 无法使用索引
6. Join 语句中Join 条件字段类型不一致的时候MySQL 无法使用索引
7. 使用LIKE 操作的时候如果条件以通配符开始（ '%abc...'）MySQL 无法使用索引
8. 使用非等值查询的时候MySQL 无法使用Hash 索引

自建索引，对全文本搜索有奇效，可用于解决like查询的扫表问题


## SQL语句
## 主从复制
## 分库分表
### 垂直分表
将表按照功能模块、关系密切程度划分出来，部署到不同的数据表上。
* 比如user表中和user_details表。
* 比如博客表中的title和content表
* 大字段垂直切分

垂直切分的优点
数据库的拆分简单明了，拆分规则明
◆ 应用程序模块清晰明确，整合容易
◆ 数据维护方便易行，容易定位

垂直切分的缺点
◆部分表关联无法在数据库级别完成，需要在程序中完成
◆对于访问极其频繁且数据量超大的表仍然存在性能瓶颈，不一定能满足要求
◆事务处理相对更为复杂
◆切分达到一定程度之后，扩展性会遇到限制
◆过度切分可能会带来系统过渡复杂而难以维护


### 水平分表
依据的条件可以是时间、地域、功能等比较清晰的条件
* 比如财务报表、薪资发放就可以用时间进行水平分割；
* 比如商品库存就可以用地域进行分割
* 比如用户表的普通用户、商户就可以用功能来进行划分


**水平通用分表策略**
1. 以uuid作为全局唯一标识，为每一个新生成的用户生成uuid
2. 将uuid进行md5加密，生成16进制随机字符串，取随机字符串前两位进行10进制转换，对分表数量的取余，获取插入的表后缀名。
3. 比如建立8张表，对8取余，则会生成user_0...user_7，每个用户会随机插入这8张表中

**分表后，如何统计数据？**
所有统计数据都是根据业务需求而来的，原始数据存在的情况，我们可以进行自建索引，实现具体的业务需求。比如根据添加时间自建索引

** 分表后查询效率的问题？** 
* 根据自建索引表，获取uuid，再根据uuid获取数据每一行的数据。只不过多了一个10次的for循环而已，而php的10for循环可以说是微秒级的。
* 结果集存储的是指针
* mysql_fetch_row()读取磁盘文件
**水平切分的优点**
◆ 表关联基本能够在数据库端全部完成
◆ 不会存在某些超大型数据量和高负载的表遇到瓶颈的问题
◆ 应用程序端整体架构改动相对较少
◆ 事务处理相对简单
◆ 只要切分规则能够定义好，基本上较难遇到扩展性限制

**水平切分的缺点**
◆ 切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则
◆ 后期数据的维护难度有所增加，人为手工定位数据更困难
◆ 应用系统各模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难

### 垂直与水平联合切分的使用
**联合切分的优点**
◆ 可以充分利用垂直切分和水平切分各自的优势而避免各自的缺陷
◆ 让系统扩展性得到最大化提升
**联合切分的缺点**
◆ 数据库系统架构比较复杂，维护难度更大；
◆ 应用程序架构也相对更复杂；


## 锁表
MySQL 各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定
### 行级锁定（row-level）

### 表级锁定（table-level）

### 页级锁定（page-level）


## 数据类型
## 缓存

